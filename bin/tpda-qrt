#!/usr/bin/perl
# +---------------------------------------------------------------------------+
# | Name     : tpda-qrt (TPDA - Query Repository Tool)                        |
# | Author   : Stefan Suciu  [ stefansbv 'at' users . sourceforge . net ]     |
# | Website  : http://tpda-qrt.sourceforge.net                                |
# |                                                                           |
# | Copyright (C) 2010  Stefan Suciu                                          |
# |                                                                           |
# | This program is free software; you can redistribute it and/or modify      |
# | it under the terms of the GNU General Public License as published by      |
# | the Free Software Foundation; either version 2 of the License, or         |
# | (at your option) any later version.                                       |
# |                                                                           |
# | This program is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of            |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             |
# | GNU General Public License for more details.                              |
# |                                                                           |
# | You should have received a copy of the GNU General Public License         |
# | along with this program; if not, write to the Free Software               |
# | Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA |
# +---------------------------------------------------------------------------+
# |
use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

use Cwd;
use File::Basename;
use File::HomeDir;
use File::Find::Rule;
use File::Spec::Functions;
use File::Path 2.07 qw( make_path remove_tree );
use File::Copy;

# Parse options and print usage if there is a syntax error,
# or if usage was explicitly requested.
my $help    = '';
my $man     = '';
my $verbose = 1;     # default option
my $list;
my $user;
my $pass;
my $init;

# Process options.
if ( @ARGV > 0 ) {
    GetOptions(
        'help|?'    => \$help,
        'man'       => \$man,
        'list:s'    => \$list,
        'user=s'    => \$user,
        'password=s'=> \$pass,
        'verbose+'  => \$verbose,
        'quiet'     => sub { $verbose = 0 },
        'init'      => \$init,
        ),
        or pod2usage(2);
}
if ( $man or $help or $#ARGV >= 0 ) {
    pod2usage(1) if $help;
    pod2usage( VERBOSE => 2 ) if $man;
}

my $conn = shift;         # Runtime configuration name or database name

#- Options
my $opts = {};

my $home = File::HomeDir->my_home;

# Build in variables
my $cfg_p = '.tpda-qrt';
my $src_p = 'etc';
my $cfg_n = 'general.yml';

# User configuration path
$opts->{cfg_path} = catdir($home, $cfg_p);

# General configurations file
$opts->{cfg_gen} = catfile($home, $cfg_p, $src_p, $cfg_n);

if (defined $conn) {
    $opts->{conn} = $conn;
}

# Check 'list' and 'init' option first
if ( defined $list xor defined $init) {
    if ( defined $list ) {
        list_configs();
        exit 0;
    }
    if ( defined $init ) {
        if (defined $conn) {
            init_configs($conn);
            exit 0;
        }
        else {
            pod2usage(1);
        }
    }
}

# if ( !check_config_paths() ) {
#     print "Configuration not setup properly!\n";
#     print " Run tpda-qrt -init\n";
#     print " and edit the configuration files\n";
#     exit;
# }

#- Other options; add them after check
$opts->{verbose} = $verbose;
$opts->{user} = $user;
$opts->{pass} = $pass;

# Check database option last
if ( exists $opts->{conn} ) {

    # Go and run the app
    use Qrt;
    my $app = Qrt->new( $opts )->run;

    print "Normal exit.\n";
    exit 0;
}

# If no other option, usage
pod2usage(1);


#-- Subs

sub init_configs {
    my $cfg_name = shift;

    create_tree($cfg_name);
    copy_defaults($cfg_name);
}

sub check_config_paths {

    foreach my $item ( keys %{$opts} ) {

        # print ' : ', $item, '->', $opts->{$item}, "\n";

        if ( $item =~ m{_p$} ) {
            check_path( $opts->{$item} );
        }
        elsif ( $item =~ m{_qn$} ) {
            check_file( $opts->{$item} );
        }
    }

    return 1;
}

sub check_path {
    my $path = shift;

    if (!-d $path) {
        print "Config error:\n";
        print "  $path does not exist?\n";
        exit;
    }
}

sub check_file {
    my $file_qn = shift;

    if (!-f $file_qn) {
        print "Config error:\n";
        print "  $file_qn does not exist?\n";
        exit;
    }
}

sub list_configs {

    my $dir = $opts->{db_root_p};

    my $conn_list = find_subdirs($dir);

    foreach my $cfg_name ( @{$conn_list} ) {
        print " - $cfg_name\n";
        my $conn_cnf_qn = catdir( $dir, $cfg_name, 'etc' );
        my $configs = locate_configs($conn_cnf_qn);
        if ( ref $configs ) {
            foreach my $config ( @{$configs} ) {
                print "   : $config\n";
            }
        }
        else {
            print "   : $configs\n";
        }
    }
}

sub locate_configs {
    my $dir = shift;

    my $cfg_fn = find_config_files($dir);

    # Number of config files found
    my $no_cfg = scalar @{$cfg_fn};
     if ( $no_cfg == 1 ) {
        $opts->{db_cnf_fqn} = catfile( $opts->{db_cnf_p}, $cfg_fn->[0] );
        return $cfg_fn->[0];
    }
    else {
        # Multiple config files
        return $cfg_fn;
    }
}

sub find_subdirs {

    my $dir = shift;

    # Find all the sub directories of a given directory
    my $rule = File::Find::Rule->new
        ->mindepth(1)
        ->maxdepth(1);
    # Ignore git
    $rule->or(
        $rule->new
            ->directory
            ->name('.git')
            ->prune
            ->discard,
        $rule->new);

    my @subdirs = $rule->directory->in( $dir );

    my @dbs = map { basename($_); } @subdirs;

    return \@dbs;
}

sub find_config_files {

    my $dir = shift;

    my @files = File::Find::Rule
        ->mindepth(1)
        ->maxdepth(1)
        ->relative
        ->file->name( '*.yml' )
        ->in( $dir );

    return \@files;
}

sub create_tree {
    my $cfg_name = shift;

    my $cfg_dir = $opts->{cnf_p};

    make_path(
        "$cfg_dir/db/$cfg_name/etc", "$cfg_dir/db/$cfg_name/qdf",
        "$cfg_dir/etc/interfaces",   "$cfg_dir/etc/template",
        { error => \my $err }
    );
    if (@$err) {
        for my $diag (@$err) {
            my ($file, $message) = %$diag;
            if ($file eq '') {
                print "Error: $message\n";
            }
            else {
                print "$file: $message\n";
            }
        }
    }
    else {
        print "Configuration tree initialized\n";
    }
}

sub copy_defaults {
    my $cfg_name = shift;

    my $cwd  = getcwd();
    my $home = File::HomeDir->my_home;

    my $cfg_dir = $opts->{cnf_p};

    print "Copying configuration files\n";

    my $src1_fqn = catdir( $cwd, 'share/config/interfaces/toolbar.yml' );
    my $dst1_p   = catdir( $cfg_dir, 'etc/interfaces' );
    copy_files($src1_fqn, $dst1_p);

    my $src2_fqn = catdir( $cwd, 'share/template/tpda-qrt.yml' );
    my $dst2_p   = catdir( $cfg_dir, 'db', $cfg_name, 'etc' );
    copy_files($src2_fqn, $dst2_p);

    my $src3_fqn = catdir( $cwd, 'share/template/template.qdf' );
    my $dst3_p   = catdir( $cfg_dir, '/etc/template' );
    copy_files($src3_fqn, $dst3_p);
}

sub copy_files {
    my ($src_fqn, $dst_p) = @_;

    if ( !-f $src_fqn ) {
        print "Source not found:\n $src_fqn\n";
        return;
    }
    if ( !-d $dst_p ) {
        print "Destination path not found:\n $dst_p\n";
        return;
    }

    my ($file) = fileparse($src_fqn);
    my $dst_fqn = catfile($dst_p, $file);
    if ( -f $dst_fqn ) {
        print "skipping $src_fqn\n";
        return;
    }

    # Copy if we got this far
    print "$src_fqn -> $dst_p\n";
    copy( $src_fqn, $dst_p ) or die $!;
}

__END__

=head1 NAME

tpda-qrt - TPDA - Query Repository Tool

=head1 SYNOPSIS

tpda-qrt -init <config_name>

tpda-qrt <config_name> [-user <user> [-password <pass>]]

tpda-qrt -list

Options:

 -init <config_name>   Initialize (create) configuration tree
 -list                 List available configuration names and files
 -user                 User name
 -password             Password
 -help                 Brief help message
 -man                  Full documentation
 -verbose              Increase the verbosity of the output

=head1 DESCRIPTION

TPDA - Query Repository Tool - a wxPerl GUI tool for data exporting
and query repository management. Queries are saved in XML files and
can be edited and parametrized.

=head1 OPTIONS DETAILS

=over

=item B<-init> <config_name>

Initialize (create) configuration tree and copy the default
configuration files.  A configuration name is required.

A configuration name is the name of the directory underneath the
'.tpda-qrt/db/ ' path.  This directory can contain one or more
configuration files.  The configuration files are in YAML format, the
format described in the documentation of the YAML::Tiny module.

=item B<-list>

List all configuration names and configuration file names.  Usually a
configuration name is the same as the database name, but this is not a
requirement.

=item B<-user>

Sets the user name.  If the user is specified but not the password than
the login dialog will ask only for the password.  If both the password
and user are provided then the login dialog will be skipped.

=item B<-password>

Sets the password.  If the user option is not specified than show
usage and exit.  If the user is specified skip the login dialog.

=item B<-man>

Prints the manual page and exits.

=item B<-verbose>

Increase the verbosity of the output. This option is incremental.

=back

=head1 LICENSE

Copyright (C) 2010  Stefan Suciu
This program is free software, you can redistribute it and/or
modify it under the terms of GNU General Public License.

=head1 AUTHOR

Stefan Suciu <stefansbv 'at' users . sourceforge . net>

=cut
